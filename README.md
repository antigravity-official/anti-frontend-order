# 안티그래비티 프론트엔드 기술과제

## 요구사항 반영 설명서

1. 기존의 Order 내부에 Shipping과 OrderProduct(n)이 있는 구조에서 Order 내부에 Shipping(n)이 있고, 각 Shipping 안에 OrderProduct(n)이 있는 구조로 변경해야 했습니다.
   따라서 기존의 모델도 수정이 있었습니다.

   - 각 상품들은 배송정보에 묶여서 표시되도록 변경했습니다.
   - 이에따라 기존 모델도 order 내부에 shipping과 orderProduct[]가 있는 형태에서
     order내부에 shipping[]이 존재하며, 각 shipping내부에 orderProduct[]가 존재하는 형태로 변경하였습니다.

2. 하나로 통합되어있던 페이지를 컴포넌트 단위로 재구성 했습니다.

   - 기본적인 주분의 정보를 보여주는 Order 컴포넌트
   - 배송지의 정보를 보여주는 Shipping 컴포넌트
   - 물품의 정보를 보여주는 OrderProduct 컴포넌트

   로 구성되어 있으며 각 컴포넌트를 App에서 렌더링하는 형식입니다.
   단, OrderProduct는 요구사항에 정의된대로, 배송정보인 Shipping에 묶어 표시되고 있습니다.

   추가로 각 정보들이 독립적인 객체로 쓰일 가능성을 고려하여 각 컴포넌트들간의 종속성은 존재하지 않습니다. 하지만 Shipping은 children을 통해 상품정보들을 묶어서 표시할 수 있게 되어있습니다.

   이를 통해 상태관리에 용이할 것으로 생각됩니다.

3. Api파일을 통해 Api호출 로직을 분리하였습니다. Api Response 데이터 가공및 호출 로직을 따로 관리함으로써 추후 유지보수에 용이할 것으로 생각됩니다.

4. Order, Shipping, OrderProduct 각 타입의 property에 따른 string값을 매핑시켜 출력하고 있습니다.

   - 추후 타입이 변하더라도 기존에 존재하는 property들은 그대로 표시될 것입니다.
   - 추후 타입이 변한다면 해당하는 값을 추가하면 자연스럽게 문구가 추가될 것입니다.

## 프로그램 구조
![anti-frontend-diagram](https://user-images.githubusercontent.com/31910942/235932773-3554d5a6-e054-41fa-b041-e2411cf4c67b.png)

## 변경된 JSON 포맷이 예상과 다를 때

- 포맷이 변경되는 경우,
  본 프로그램은 Order내부에 모든 정보가 들어있는 형태에서 요구사항에 정의된대로,
  Order 내부에는 Shipping[], Shipping내부에 OrderProduct[]가 들어갈 것을 전제로 하여 개발하였기 때문에, 약간의 변동이 있을 수 밖에 없습니다.

  단, 그럼에도 각 컴포넌트는 특정 컴포넌트에 종속된 형태가 아니므로 데이터를 정제, 배포하는 과정을 수정하고 추가된 property에 해당하는 문자값을 추가하는 것으로 대응할 수 있을것으로 생각됩니다.

- 정확하게는, 다음과 같은 과정을 거칠것으로 생각됩니다.
  - Model.ts 에 정의된 데이터 형식을 변경합니다.
  - api폴더 내부의 orderApi의 데이터 호출/데이터 정제 함수를 수정합니다.
  - App.ts 파일에서, 변경된 형식에 따라 각 컴포넌트가 원하는 값을 얻을 수 있게끔 값을 할당합니다.
  - 각 데이터에서 추가/삭제된 property에 따라 constants.ts 내부에 정의된 화면에 보여질 문자열 값들을 수정합니다.
